---
author: Hugo Authors
title: 链表
date: 2022-11-03
description: 算法与数据结构
series:
  - 算法与数据结构

---
单链表
<!--more-->
# 链表的基本概念
链表别名`链式存储结构`、`单链表`，用于存储结构关系为一对一的数据。与顺序表不一样的地方在于，链表并不限制存储数据的物理状态，使用链表存储数据是随机存放位置的。
![](/images/链表随机存储数据.jpg)
数据元素随机存储数据，并通过指针表示数据之间逻辑关系的存储结构就是链式存储结构。
## 链表的节点
从上面的图片可以看出，链表中每个数据的组成分为两个部分：
- 数据元素本身，其所在区域称为`数据域`。
- 指向直接后继元素的指针所在区域称为指针域。
![](/images/节点结构.jpg)
![](/images/链表中的节点.jpg)
和顺序表一样都要使用到结构体来定义每个存储节点：
```c
typedef struct Link{
  char elem;//代表数据域
  struct Link * next;//代表指针域，指向直接后继元素
}link;//link为节点名，每个节点都是一个link结构体
```
由于指针域指向的也是一个节点，所以用`struct Link *`来声明。
## 头节点，头指针和首元节点
实际上上面的图并不能表示出完整的链表
![](/images/完整链表示意图.jpg)
1. 头指针：一个普通的指针，它的特点是永远指向链表中的第一个元素节点的位置，也就是说头指针用于指明链表的位置，便于后期找到链表并使用链表中的数据。
2. 节点：
    - 头节点：其实就是一个不存储任何数据的空节点，通常作为链表的第一个节点，对于链表来说，头节点并不是必须的，它的出现只是为了解决一些实际问题。
    - 首元节点：由于头节点（也就是空节点）的缘故，链表中存储数据的第一个节点就被称为首元节点，首元节点这个名词只是对第一个存数据的节点的一个称呼，没有实际意义。
    - 其他节点：链表中其他的节点。

```
需要注意的是，如果有头节点，头指针指向头节点，如果没有头指针指向首元节点。
```
## 链表的创建
创建一个链表需要做如下工作：
1. 声明一个头指针（如果有必要，可以声明一个头节点）
2. 创建多个存储数据的节点，在创建的过程中，要随时与其前驱节点建立逻辑关系。
```c
link * initLink(){
  link * p = NULL;//创建头指针
  link * temp = (link *)malloc(sizeof(link));//创建首元节点
  
  //首元节点初始化
  temp->elem = 1;
  temp->next = NULL;
  p = temp;//头指针指向首元节点
  // 第二个节点开始创建
  for(int i=2;i<5;i++){
    //创建一个新节点并初始化
    link * a = (link *)malloc(sizeof(link));
    a->elem = i;
    a->exit = NULL;
    //将temp节点指向新建立的a的节点建立逻辑关系
    temp->next = a;
    //指针temp指针一直指向新链表中的最后一个节点，在这里写temp=a也对
    temp=temp->next;
  }
  //返回建立的节点，只返回头指针p即可，我们需要通过头指针来找到这个链表。
  return p;
}
```
如果想要创建一个含有头节点的链表：
```c
link * initLink(){
  link * p = (link *)malloc(sizeof(link));
  link * temp = p;//声明一个指针指向头节点
  //生成链表
  for(int i;i<5;i++){
    link * a = (linnk *)malloc(sizeof(link));
    a->elem = i;
    a->next = NULL;
    temp->next = a;
    temp = temp->next;
  }
  return p;
}
```
和顺序表差不多，我们只需要调用函数就可以创建链表：
```c
#include <stdio.h>
#include <stdlib.h>
//链表中节点的结构
typedef struct Link{
  char elem;
  struct Link * next;
}link;
//初始化链表的函数
link * initLink(){
  link * p = NULL;
  link * temp = (link *)malloc(sizeof(link));
  temp->elem = 1;
  temp->next = NULL;
  p = temp;
  for(int i=2;i<5;i++){
    link * a = (link *)malloc(sizeof(link));
    a->elem = i;
    a->next = NULL;
    temp->next = a;
    temp = temp->next;
  }
  return p;
}
void display(link *p){
  link * temp = p;//将temp指针重新指向头节点
  //只要temp指针指向的节点的next不是NULL，就执行输出语句。
  while(temp){
    printf("%d",temp->elem);
    temp=temp->next;
  }
  printf("\n");
}
int main(){
  //初始化链表（1.2.3.4）
  printf("初始化链表为：\n");
  link * p=initLink();
  display(p);
  return 0;
}
```
程序运行结果：
```
初始化链表为：
1234
```
但是我们要是使用具有头节点的方式创建新链表，则我们的输出有些变化就是display函数做出相应的修改：
```c
void display (link *p){
  link * temp = p//这个不变，还是将temp指针重新指向头节点。
  //只要temp指针指向的节点的next不是NULL，就执行输出语句。
  while(temp->next){
    temp=temp->next;
    printf("%d",temp->elem);
  }
  printf("\n");
}
```